# 09、标签拖拽细节优化说明

> 本文档记录了对标签拖拽功能的细节优化

## 优化时间
2026-01-15

## 优化内容

### 1. 优化单标签面板组的合并指示器显示逻辑

**问题**：当拖拽只有一个标签的面板组时，会显示合并指示器和文案，这不符合用户预期，因为这实际上是在拖动整个面板组。

**解决方案**：
- 在 `DockablePanelGroup.vue` 中优化 `showMergeIndicator` 计算属性
- 添加判断：如果源面板组只有一个标签，不显示合并指示器
- 这样单标签面板组拖动时，只会显示停靠预览，不会显示合并提示

**代码位置**：
```vue
// src/components/docking/DockablePanelGroup.vue
const showMergeIndicator = computed(() => {
  const tabDragInfo = manager.tabDragInfo?.value;
  if (!tabDragInfo) return false;
  
  // 只有悬停在当前面板组时才可能显示
  if (manager.hoveredGroup?.value !== props.group.id) return false;
  
  // 如果是在同一个面板组内拖动（调整顺序），不显示合并指示器
  if (tabDragInfo.groupId === props.group.id) return false;
  
  // 如果拖拽的源面板组只有一个标签，表示是在拖动整个面板组，不显示合并指示器
  const sourceGroup = manager.getPanelGroup?.(tabDragInfo.groupId);
  if (sourceGroup && sourceGroup.tabs.length === 1) return false;
  
  return true;
});
```

**效果**：
- 单标签面板组：拖动时不显示合并文案，只显示停靠边框
- 多标签面板组：拖动标签时正常显示合并提示

---

### 2. 同一面板组内拖动标签时不显示合并文案

**问题**：在同一面板组内拖动标签调整顺序时，会显示"拖到这里合并标签页"的文案，这是不准确的，因为这不是合并操作，而是排序操作。

**解决方案**：
- 在 `showMergeIndicator` 中添加判断
- 如果 `tabDragInfo.groupId === props.group.id`，表示在同一面板组内拖动，不显示合并指示器
- 只显示插入位置的蓝色指示线

**效果**：
- 同一面板组内：只显示插入位置指示线，不显示合并文案
- 不同面板组间：显示合并文案和高亮效果

---

### 3. 添加标签拖拽时的停靠位置预览

**问题**：拖拽标签到容器边缘或已停靠面板附近时，没有停靠位置预览，用户不知道标签会停靠到哪里。

**解决方案**：

#### 3.1 扩展类型定义
在 `types.ts` 中为 `TabDragInfo` 添加停靠区域信息：
```typescript
export interface TabDragInfo {
  groupId: string;
  tabId: string;
  startX: number;
  startY: number;
  currentX: number;
  currentY: number;
  offsetX: number;
  offsetY: number;
  hoveredGroupId?: string;
  insertIndex?: number;
  dockZone?: DockZone | null; // 停靠区域预览
}
```

#### 3.2 添加停靠检测函数
在 `useDockManager.ts` 中添加两个新函数：

1. **`detectTabDockSnap`**：检测标签拖拽时的停靠区域
   - 检测容器边缘（上下左右）
   - 检测已停靠面板/面板组的吸附区域

2. **`detectTabToDockSnap`**：具体的停靠区域计算
   - 遍历所有已停靠的面板和面板组
   - 计算停靠位置的预览尺寸
   - 返回 `SnapResult`

#### 3.3 更新拖拽逻辑
修改 `onDragTab` 函数：
```typescript
function onDragTab(clientX: number, clientY: number) {
  if (!tabDragInfo.value) return;

  tabDragInfo.value.currentX = clientX;
  tabDragInfo.value.currentY = clientY;

  // 检测是否悬停在其他面板组上
  detectTabHover(clientX, clientY);

  // 如果没有悬停在面板组上，检测停靠区域
  if (!tabDragInfo.value.hoveredGroupId) {
    const dockSnapResult = detectTabDockSnap(clientX, clientY);
    if (dockSnapResult.shouldSnap) {
      tabDragInfo.value.dockZone = {
        position: dockSnapResult.position!,
        rect: dockSnapResult.targetRect!,
      };
      hoveredZone.value = tabDragInfo.value.dockZone;
    } else {
      tabDragInfo.value.dockZone = null;
      hoveredZone.value = null;
    }
  } else {
    // 悬停在面板组上时，清除停靠预览
    tabDragInfo.value.dockZone = null;
    hoveredZone.value = null;
  }
}
```

#### 3.4 支持拆分并停靠
添加 `splitTabAndDock` 函数：
```typescript
function splitTabAndDock(sourceGroupId: string, tabId: string, dockPosition: DockPosition) {
  const sourceGroup = panelGroups.value.get(sourceGroupId);
  if (!sourceGroup) return;

  const tabIndex = sourceGroup.tabs.findIndex(t => t.id === tabId);
  if (tabIndex === -1) return;

  const tab = sourceGroup.tabs[tabIndex];

  // 从源面板组移除标签
  sourceGroup.tabs.splice(tabIndex, 1);

  // 创建新面板组并直接停靠
  const newGroupId = `group-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const newGroup: PanelGroup = {
    id: newGroupId,
    tabs: [tab],
    activeTabId: tab.id,
    width: sourceGroup.width,
    height: sourceGroup.height,
    minWidth: sourceGroup.minWidth,
    minHeight: sourceGroup.minHeight,
    x: 0,
    y: 0,
    zIndex: ++maxZIndex.value,
    state: 'docked',
    position: dockPosition,
    resizable: sourceGroup.resizable,
    dockedPanels: [],
  };

  panelGroups.value.set(newGroupId, newGroup);

  // 更新该位置的所有停靠面板/面板组的布局
  updateDockedPanelsByPosition(dockPosition);
}
```

#### 3.5 更新结束拖拽逻辑
修改 `endDragTab` 函数，支持三种情况：
1. 悬停在面板组上 → 合并或排序
2. 检测到停靠区域 → 拆分并停靠
3. 其他情况 → 拆分成浮动面板组

**效果**：
- 拖拽标签到容器边缘：显示半透明蓝色预览区域
- 拖拽标签到已停靠面板附近：显示停靠位置预览
- 释放鼠标：标签自动拆分为新面板组并停靠到预览位置

---

## 优化效果总结

### 视觉体验改进
1. **合并指示器更智能**：只在真正需要合并时才显示文案
2. **插入指示更清晰**：蓝色发光线条精确指示插入位置
3. **停靠预览更直观**：半透明区域清晰展示停靠目标位置

### 交互逻辑改进
1. **单标签面板组**：拖动时视为整个面板组移动，不显示合并提示
2. **同组内排序**：只显示位置指示线，不显示合并文案
3. **跨组合并**：显示完整的合并提示和效果
4. **停靠操作**：标签可以直接拖拽停靠，无需先拆分再停靠

### 用户体验提升
- 操作意图更明确：不同操作有不同的视觉反馈
- 学习成本更低：视觉提示准确反映操作结果
- 工作效率更高：一次拖拽完成拆分+停靠操作

---

## 测试建议

### 测试场景1：单标签面板组拖动
1. 创建一个只有一个标签的面板组
2. 拖动标签栏
3. 预期：不显示合并文案，只显示停靠预览

### 测试场景2：同组内标签排序
1. 创建一个有多个标签的面板组
2. 拖动标签在同一组内移动
3. 预期：只显示蓝色插入位置线，不显示合并文案

### 测试场景3：跨组合并标签
1. 创建两个面板组
2. 从一个组拖动标签到另一个组
3. 预期：显示"拖到这里合并标签页"文案和高亮效果

### 测试场景4：标签拖拽停靠
1. 创建一个有多个标签的面板组
2. 拖动标签到容器左侧边缘
3. 预期：显示蓝色半透明停靠预览区域
4. 释放鼠标
5. 预期：标签拆分为新面板组并停靠到左侧

### 测试场景5：标签拖拽到已停靠面板附近
1. 创建一个已停靠的面板组（如左侧）
2. 拖动另一个标签到该面板上方或下方的热区
3. 预期：显示停靠位置预览
4. 释放鼠标
5. 预期：标签拆分并停靠到指定位置，原面板自动调整尺寸

---

## 技术要点

### 1. 条件判断的优先级
```vue
// 判断顺序很重要
1. 是否有拖拽信息
2. 是否悬停在当前面板组
3. 是否同一面板组内拖动
4. 源面板组是否只有一个标签
```

### 2. 停靠检测的优先级
```typescript
// 检测顺序
1. 检测面板组标签栏（用于合并）
2. 检测容器边缘（用于停靠）
3. 检测已停靠面板/面板组（用于停靠）
```

### 3. 视觉反馈的互斥性
- 合并指示器 vs 停靠预览：二者不同时显示
- 插入位置线 vs 合并文案：根据场景选择显示

---

## 相关文件

### 修改的文件
1. `src/components/docking/types.ts` - 扩展 TabDragInfo 类型
2. `src/components/docking/useDockManager.ts` - 添加停靠检测和拆分停靠逻辑
3. `src/components/docking/DockablePanelGroup.vue` - 优化合并指示器显示逻辑

### 新增的函数
1. `detectTabDockSnap()` - 检测标签拖拽时的停靠区域
2. `detectTabToDockSnap()` - 计算标签到面板/面板组的停靠位置
3. `splitTabAndDock()` - 拆分标签并停靠到指定位置

### 修改的函数
1. `onDragTab()` - 添加停靠区域检测
2. `endDragTab()` - 支持拆分并停靠操作
3. `showMergeIndicator` (computed) - 优化显示逻辑

---

## 后续优化建议

1. **性能优化**：停靠检测可以增加防抖，减少计算频率
2. **动画优化**：拆分并停靠时可以添加过渡动画
3. **可配置性**：停靠热区大小可以作为配置项
4. **辅助提示**：可以添加键盘快捷键说明（如按住 Shift 强制拆分）

---

## 版本信息
- 优化版本：v1.4
- 优化日期：2026-01-15
- 优化人员：AI Assistant
