# 拖拽问题修复说明

## 问题描述

用户反馈：点击面板组后，背景变成半透明（进入拖拽状态），但是无法实际拖动面板组。

## 问题原因

### 1. **核心问题：onDrag 和 endDrag 未处理面板组**

在 `useDockManager.ts` 中，`onDrag` 和 `endDrag` 方法只处理了旧的单面板系统（`panels`），没有处理新的面板组系统（`panelGroups`）。

**原代码：**
```typescript
function onDrag(clientX: number, clientY: number) {
  if (!dragInfo.value) return;
  
  const panel = panels.value.get(dragInfo.value.panelId);
  if (!panel) return; // 这里会直接返回，因为 panelId 是面板组的 ID
  
  // 更新位置...
}
```

当拖拽面板组时：
1. `startDragGroup` 设置 `dragInfo.panelId` 为面板组 ID
2. `onDrag` 尝试从 `panels` 获取，返回 `undefined`
3. 方法直接返回，位置不更新
4. 结果：状态变成 `dragging`，但位置不动

### 2. **次要问题：DockContainer 渲染结构混乱**

停靠的面板组被单独渲染在独立的 `dock-area` 容器中，不在主布局流中，导致布局混乱。

### 3. **事件处理问题**

标签页的 mousedown 事件没有正确阻止冒泡和默认行为，可能导致事件冲突。

## 修复方案

### 1. **修复 onDrag 方法**

让 `onDrag` 同时支持面板和面板组：

```typescript
function onDrag(clientX: number, clientY: number) {
  if (!dragInfo.value) return;

  // 尝试获取面板或面板组
  const panel = panels.value.get(dragInfo.value.panelId);
  const group = panelGroups.value.get(dragInfo.value.panelId);
  
  const target = panel || group;
  if (!target) return;

  // 更新位置
  dragInfo.value.currentX = clientX;
  dragInfo.value.currentY = clientY;

  target.x = clientX - dragInfo.value.offsetX;
  target.y = clientY - dragInfo.value.offsetY;

  // ... 其他逻辑
}
```

### 2. **修复 endDrag 方法**

同样让 `endDrag` 支持两种类型：

```typescript
function endDrag() {
  if (!dragInfo.value) return;

  // 尝试获取面板或面板组
  const panel = panels.value.get(dragInfo.value.panelId);
  const group = panelGroups.value.get(dragInfo.value.panelId);

  if (!panel && !group) {
    dragInfo.value = null;
    hoveredZone.value = null;
    return;
  }

  // 分别处理面板和面板组
  if (panel) {
    // 面板的停泊逻辑
  }

  if (group) {
    // 面板组的停泊逻辑
    group.state = 'floating';
    group.position = 'float';
  }

  dragInfo.value = null;
  hoveredZone.value = null;
}
```

### 3. **重构 DockContainer 模板**

将停靠的面板组整合到主布局的停靠区内：

```vue
<template>
  <!-- 顶部停靠区 -->
  <div v-if="topPanels.length > 0 || topPanelGroups.length > 0" 
       class="dock-area dock-top">
    <!-- 面板 -->
    <DockablePanel v-for="panel in topPanels" ... />
    <!-- 面板组 -->
    <DockablePanelGroup v-for="group in topPanelGroups" ... />
  </div>
</template>
```

### 4. **修复事件处理**

添加事件阻止，防止冲突：

```typescript
function handleTabMouseDown(e: MouseEvent, tab: TabItem) {
  e.preventDefault();
  e.stopPropagation(); // 防止触发父容器的拖拽
  
  // ... 启动标签页拖拽
}

function handleTabsMouseDown(e: MouseEvent) {
  const target = e.target as HTMLElement;
  if (target.closest('.panel-tab')) {
    return;
  }
  
  e.preventDefault();
  
  // 拖动整个面板组
  manager.startDragGroup?.(props.group.id, e.clientX, e.clientY);
}
```

## 修复后的效果

✅ 面板组可以正常拖拽  
✅ 拖拽时位置实时更新  
✅ 拖拽结束后状态正确  
✅ 标签页拖拽不会触发面板组拖拽  
✅ 布局结构清晰，停靠面板组显示正确  

## 测试方法

1. 访问 `/docking-group-demo` 页面
2. 点击"添加面板"按钮创建面板组
3. 拖动标签栏空白区域
4. 验证面板组可以正常移动
5. 释放鼠标，验证面板组停留在新位置

## 相关文件

- `src/components/docking/useDockManager.ts` - 核心拖拽逻辑
- `src/components/docking/DockContainer.vue` - 容器组件
- `src/components/docking/DockablePanelGroup.vue` - 面板组组件

## 后续优化建议

1. **面板组停靠检测**  
   当前面板组拖拽结束后直接变为浮动状态，未检测停泊区。可以添加类似面板的停泊检测逻辑。

2. **拖拽性能优化**  
   可以添加节流函数优化 `onDrag` 的调用频率。

3. **拖拽视觉反馈增强**  
   可以添加拖拽时的阴影动画、弹性效果等。

4. **边界约束**  
   可以添加面板组的边界约束，防止拖出可视区域。

---

**修复日期**: 2026-01-14  
**修复版本**: v1.0.1  
**状态**: ✅ 已修复
